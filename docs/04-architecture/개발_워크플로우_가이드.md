# TechBuddy 개발 워크플로우 가이드

**작성일**: 2025-11-17  
**작성자**: 윤종호  
**버전**: v1.0  
**프로젝트**: TechBuddy MVP

---

## 📋 목차

1. [프로젝트 구조 (모노레포)](#1-프로젝트-구조-모노레포)
2. [초기 프로젝트 셋업](#2-초기-프로젝트-셋업)
3. [Linear 활용](#3-linear-활용)
4. [브랜치 전략](#4-브랜치-전략)
5. [브랜치별 보호 규칙](#5-브랜치별-보호-규칙)
6. [역할별 일일 작업 프로세스](#6-역할별-일일-작업-프로세스)
7. [커밋 컨벤션](#7-커밋-컨벤션)
8. [코드 리뷰 가이드](#8-코드-리뷰-가이드)
9. [향후 계획](#9-향후-계획)

---

## 1. 프로젝트 구조 (모노레포)

### 1.1 모노레포란?

**TechBuddy는 모노레포(Monorepo) 방식으로 구성되어 있습니다.**

모노레포는 하나의 Git 저장소에 여러 개의 프로젝트(Backend, Frontend)를 함께 관리하는 방식입니다.

```
TechBuddy_MVP/
├── backend/           # NestJS 백엔드 프로젝트
│   ├── package.json   # 백엔드 전용 의존성
│   ├── src/
│   └── ...
│
├── frontend/          # Nuxt 3 프론트엔드 프로젝트
│   ├── package.json   # 프론트엔드 전용 의존성
│   ├── pages/
│   ├── components/
│   └── ...
│
├── docs/              # 프로젝트 문서
│   ├── 개발_워크플로우_가이드.md
│   ├── TechBuddy_기획서_v1_3.md
│   └── ...
│
├── .gitignore         # 전체 프로젝트 Git 설정
└── README.md          # 프로젝트 전체 README
```

### 1.2 모노레포의 장점

| 장점 | 설명 |
|------|------|
| **코드 공유 용이** | 공통 타입, 유틸리티를 쉽게 공유 가능 |
| **통합 버전 관리** | Backend와 Frontend를 하나의 브랜치 전략으로 관리 |
| **문서 중앙화** | 모든 문서를 한 곳에서 관리 |
| **배포 동기화** | API 변경 시 Frontend도 동시에 업데이트 가능 |
| **개발 환경 일관성** | 팀원 모두 동일한 프로젝트 구조 사용 |

### 1.3 각 프로젝트 독립성

**중요**: Backend와 Frontend는 **별도의 package.json**을 가지며, **독립적으로 개발 서버를 실행**합니다.

| 항목 | Backend | Frontend |
|------|---------|----------|
| 프레임워크 | NestJS | Nuxt 3 |
| 포트 | 3000 | 3001 |
| 의존성 관리 | backend/package.json | frontend/package.json |
| 개발 서버 | `npm run start:dev` | `npm run dev` |
| 배포 | Railway (별도) | Railway (별도) |

### 1.4 왜 모노레포를 선택했는가?

#### ✅ 선택 이유
- **5인 소규모 팀**: 복잡한 멀티 레포 관리 불필요
- **MVP 단계**: API 스펙 변경이 빈번하여 통합 관리 유리
- **문서 중앙화**: 기획서, API 명세서, 가이드를 한 곳에서 관리
- **브랜치 전략 단순화**: Backend/Frontend 동시 작업 시 충돌 관리 용이

#### ⚠️ 향후 고려사항
- 팀 규모 확장 시 멀티 레포 전환 검토 가능
- 현재는 모노레포가 최적의 선택

---

## 2. 초기 프로젝트 셋업

**새로운 PC에서 TechBuddy 프로젝트를 클론하여 작업을 시작하는 방법**

### 2.1 사전 준비

다음 도구들이 설치되어 있어야 합니다:

- **Git** (버전 관리)
- **Node.js** v20.x 이상 (LTS 권장)
- **npm** v10.x 이상
- **VS Code** (선택사항, 권장)

### 2.2 프로젝트 클론

```bash
# 1. Git 저장소 클론
git clone <repository-url>
cd TechBuddy_MVP

# 2. 기본 브랜치 확인
git branch -a
# * dev (현재 브랜치)

# 3. dev 브랜치로 이동 (이미 dev에 있을 수 있음)
git checkout dev
```

### 2.3 Backend 셋업

```bash
# 1. Backend 디렉토리로 이동
cd backend

# 2. 의존성 설치
npm install

# 3. 환경 변수 설정
# .env 파일 생성 (팀 리더에게 요청하거나 아래 내용 참고)
```

**.env 파일 예시** (팀 리더에게 실제 값 요청):
```env
# 데이터베이스
DATABASE_URL="postgresql://user:password@host:port/database"

# JWT 시크릿
JWT_SECRET="your-jwt-secret-key"
JWT_EXPIRES_IN="7d"

# 환경
NODE_ENV="development"

# 포트
PORT=3000
```

```bash
# 4. 데이터베이스 마이그레이션 (Supabase 사용 시)
# Supabase Studio에서 스키마 확인 또는 생성

# 5. 개발 서버 실행
npm run start:dev

# ✅ 성공 시 출력:
# [Nest] Application successfully started on: http://localhost:3000
```

### 2.4 Frontend 셋업

**새 터미널 창 열기** (Backend 서버는 계속 실행)

```bash
# 1. 프로젝트 루트로 돌아가기
cd ..  # backend에서 TechBuddy_MVP로

# 2. Frontend 디렉토리로 이동
cd frontend

# 3. 의존성 설치
npm install

# 4. 환경 변수 설정 (선택사항)
# .env 파일 생성
```

**.env 파일 예시** (Frontend):
```env
# Backend API URL
NUXT_PUBLIC_API_BASE_URL="http://localhost:3000"

# 환경
NUXT_PUBLIC_ENVIRONMENT="development"
```

```bash
# 5. 개발 서버 실행
npm run dev

# ✅ 성공 시 출력:
# Nuxt 4.2.1 with Nitro 2.x.x
# ➜ Local:   http://localhost:3001/
```

### 2.5 동작 확인

#### Backend 확인
```bash
# 새 터미널 또는 브라우저에서:
curl http://localhost:3000/api

# 또는 브라우저에서 http://localhost:3000/api 접속
```

#### Frontend 확인
```
브라우저에서 http://localhost:3001 접속
→ TechBuddy 홈페이지가 보여야 함
```

### 2.6 개발 준비 완료!

이제 다음 작업을 시작할 수 있습니다:

```bash
# 1. Linear에서 오늘 할당된 이슈 확인
# 2. dev 브랜치에서 작업 시작
git checkout dev
git pull origin dev  # ⚠️ 작업 전 항상 최신화!

# 3. Backend 작업 시:
cd backend
# 코드 작성...
git add .
git commit -m "feature: 작업 내용, TECH-XXX"
git push origin dev

# 4. Frontend 작업 시:
cd frontend
# 코드 작성...
git add .
git commit -m "feature: 작업 내용, TECH-XXX"
git push origin dev
```

### 2.7 자주 발생하는 문제

#### 문제 1: `npm install` 실패
```bash
# 해결:
rm -rf node_modules package-lock.json
npm install
```

#### 문제 2: Backend 서버 실행 안됨
```bash
# DATABASE_URL 확인
cat .env | grep DATABASE_URL

# Supabase 연결 테스트
# Supabase Studio에서 데이터베이스 상태 확인
```

#### 문제 3: Frontend 페이지 렌더링 안됨
```bash
# .nuxt 캐시 삭제 후 재시작
rm -rf .nuxt
npm run dev
```

#### 문제 4: 포트 이미 사용 중
```bash
# 포트 3000 사용 중:
lsof -i :3000
kill -9 <PID>

# 포트 3001 사용 중:
lsof -i :3001
kill -9 <PID>
```

### 2.8 추가 설정 (선택사항)

#### VS Code 확장 프로그램 (권장)
```
- ESLint
- Prettier
- GitLens
- Vue - Official (Volar)
- Thunder Client (API 테스트)
```

#### Git 설정
```bash
# 사용자 정보 설정
git config user.name "Your Name"
git config user.email "your.email@example.com"

# 기본 에디터 설정
git config core.editor "code --wait"
```

---

## 3. Linear 활용

### 3.1 목적
```
* 5인 팀의 효율적인 프로젝트 관리 및 협업 강화
* 모든 개발 작업의 시작점으로 활용
* 이슈 기반 개발 문화 확립
```

### 3.2 기본 사용 규칙
* **모든 작업은 Linear 이슈 생성부터 시작**
* 이슈 ID 형식: `TECH-000` (TechBuddy의 약자)
* 이슈는 계층 구조와 타입에 따라 작성

### 3.3 이슈 계층 구조 및 타입

#### Level 1: `[EPIC]`
* **정의**: 여러 단계의 작업이 필요한 크고 복합적인 기능 또는 목표
* **예시**: `[EPIC] 커뮤니티 기능 구현`, `[EPIC] 프로젝트 관리 도구 개발`
* **설명**: Epic은 하나 이상의 Phase 또는 Task로 구성됩니다. 프로젝트의 큰 그림을 나타냅니다.

#### Level 2: `[Phase N]`
* **정의**: Epic을 완수하기 위한 순차적 또는 논리적 단계
* **예시**: `[Phase 1] 커뮤니티 기반 구축`, `[Phase 2] 프로젝트 관리 핵심 기능`
* **설명**: Epic의 하위 이슈로 생성하며, 특정 기간 동안의 작업 단위를 명확히 합니다.

#### Level 3: 일반 타입 (`feature`, `fix` 등)
* **정의**: 개발자가 실제로 수행하는 가장 작은 단위의 작업
* **예시**: `feature: 등급별 게시판 API 개발`, `fix: 로그인 버그 수정`
* **설명**: Epic 또는 Phase의 하위 이슈로 생성될 수 있으며, 커밋 컨벤션의 타입을 접두사로 사용

#### 타입 종류
* `feature`: 새로운 기능 추가
* `fix`: 버그 수정
* `docs`: 문서 수정 (API 명세서, README 등)
* `style`: 코드 포맷팅, 리팩토링 (동작 변경 없음)
* `test`: 테스트 코드 관련 작업
* `chore`: 기타 작업 (빌드, 설정, 의존성 업데이트)

---

## 4. 브랜치 전략

### 4.1 현재 전략: 3-Branch Strategy

TechBuddy는 MVP 단계로 **소수 인원(5명)** 작업이므로 3 브랜치 전략을 채택합니다.

```
dev (개발) → test (테스트) → main (프로덕션)
```

> **참고**: 향후 팀 규모 확장 시 Feature Branch 전략으로 전환 예정

### 4.2 브랜치별 용도

| 브랜치 | 용도 | 환경 | 자동 배포 |
|--------|------|------|----------|
| `dev` | 모든 개발 작업 | 로컬 개발 환경 | ❌ |
| `test` | 테스트 서버 배포 | Railway (Test) | ✅ |
| `main` | 프로덕션 배포 | Railway (Production) | ✅ |

#### dev 브랜치
* 모든 개발 작업이 이루어지는 중심 브랜치
* 직접 push 가능 (보호 규칙 없음)
* 팀원들이 공동으로 작업

#### test 브랜치
* 개발 완료 후 테스트 서버에 배포
* QA 및 통합 테스트 진행
* **직접 push 금지**, PR 필수

#### main 브랜치
* 실제 서비스 배포용 (프로덕션)
* **직접 push 금지**, PR + 코드 리뷰 필수
* 항상 안정적인 상태 유지

### 4.3 전략 특징
* ✅ Feature 브랜치 없이 dev 브랜치에서 직접 작업
* ✅ Pull Request를 통한 브랜치 간 merge 필수
* ✅ **Squash and Merge**로 깔끔한 히스토리 유지
* ⚠️ MVP 완료 후 Feature Branch 전략 도입 예정

---

## 5. 브랜치별 보호 규칙

### 5.1 보호 규칙 요약

| 브랜치 | 직접 Push | PR 필수 | 리뷰 필수 | Merge 방식 | 주요 설정 |
|--------|-----------|---------|-----------|-----------|----------|
| `dev` | ✅ | ❌ | ❌ | - | 보호 규칙 없음 |
| `test` | ❌ | ✅ | ❌ | Squash | PR 필수 |
| `main` | ❌ | ✅ | ✅ (PM) | Squash | PR + 리뷰 필수 |

### 5.2 Branch Protection 설정 방법

#### ❓ 왜 필요한가?
* ✅ 직접 push로 인한 실수 방지
* ✅ 코드 리뷰 프로세스 확립으로 코드 품질 향상
* ✅ 팀 협업 규칙 확립 및 안정적인 배포

#### 📝 GitHub 설정 경로
1. Repository → **Settings** → **Branches**
2. **Add branch protection rule** 클릭
3. 아래 설정 적용

#### test 브랜치 필수 설정
```yaml
Branch name pattern: test

필수 설정:
☑️ Require a pull request before merging
☑️ Require conversation resolution before merging
☑️ Require linear history
```

#### main 브랜치 필수 설정
```yaml
Branch name pattern: main

필수 설정:
☑️ Require a pull request before merging
   ☑️ Require approvals (1명 - PM 윤종호)
   ☑️ Dismiss stale pull request approvals when new commits are pushed
☑️ Require conversation resolution before merging
☑️ Require linear history
☑️ Do not allow bypassing the above settings (Admin 포함)
```

#### 📚 각 설정 항목 설명

| 설정 | 설명 |
|------|------|
| `Require a pull request before merging` | 직접 Push 금지, PR을 통해서만 merge 가능 |
| `Require approvals` | PR merge 전 지정된 수의 리뷰어 승인 필요 |
| `Dismiss stale pull request approvals` | 승인 후 새 커밋 추가 시 재승인 필요 |
| `Require conversation resolution` | 모든 PR 코멘트가 해결되어야 merge 가능 |
| `Require linear history` | Merge commit 생성 금지, Squash만 허용 |

---

## 6. 역할별 일일 작업 프로세스

### 6.1 개발자 일일 워크플로우 (공통)

**역할**: 프론트엔드(박지승), 백엔드(윤종호), 디자이너, 앱 개발자(박시형)

```bash
# ========== Step 1: 오늘 할 일 확인 ==========
# Linear 대시보드에서 오늘 할당된 이슈 확인
# 이슈 ID와 작업 내용 숙지

# ========== Step 2: 작업 시작 ==========
git checkout dev              # dev 브랜치로 이동
git pull origin dev           # ⚠️ 중요: 작업 시작 전 항상 최신화!

# ========== Step 3: 개발 작업 ==========
# ✨ Tip: VS Code에서 Prettier 자동 포맷팅 설정 권장
# 코드 작성...

# ========== Step 4: 커밋 & 푸시 ==========
git add .
git commit -m "feature: 등급별 게시판 목록 조회 API, TECH-042"
git push origin dev

# ========== Step 5: PR 생성 (dev → test) ==========
# GitHub에서 Pull Request 생성
# - 제목: "[TECH-042] 등급별 게시판 목록 조회 API"
# - 내용: 주요 변경사항, 테스트 방법 작성

# ========== Step 6: 로컬 테스트 ==========
# Railway Test 서버 자동 배포 대기 (약 2-3분)
# Test 서버에서 동작 확인

# ========== Step 7: PM에게 리뷰 요청 ==========
# Slack or Linear 코멘트로 리뷰 요청
```

### 6.2 PM (윤종호) 워크플로우

#### 아침 루틴
```bash
# 1. Linear 대시보드 확인
#    - 진행 중인 이슈 현황 파악
#    - 새로운 이슈 생성 및 팀원에게 할당

# 2. GitHub PR 확인
#    - 대기 중인 PR 리뷰
#    - 코드 리뷰 및 피드백
```

#### 개발 작업
```bash
# PM도 팀원과 동일하게 dev 브랜치에서 작업
git checkout dev
git pull origin dev

# 긴급 수정(Hotfix)이 필요한 경우
git checkout -b hotfix/TECH-XXX main
# 수정 후
git push origin hotfix/TECH-XXX
# PR: hotfix/TECH-XXX → main
```

#### PR 리뷰 & 배포
```bash
# test 서버 QA 진행
# ✅ 기능 동작 확인
# ✅ 버그 없는지 확인
# ✅ 성능 이슈 없는지 확인

# PR 리뷰 후 Squash and Merge
# main 브랜치로 merge
# Railway Production 자동 배포 확인
```

### 6.3 Pull Request 워크플로우

#### dev → test PR
```
1. dev 브랜치에서 작업 완료
2. GitHub에서 PR 생성 (base: test, compare: dev)
3. PR 제목: "[TECH-042] 등급별 게시판 목록 조회 API"
4. PR 설명 작성:
   - 주요 변경사항
   - 테스트 방법
   - 스크린샷 (UI 작업 시)
5. 로컬 테스트 완료 후 "Squash and merge"
6. Railway Test 서버 자동 배포 대기
7. Test 서버에서 QA 진행
```

#### test → main PR
```
1. Test 서버 QA 완료
2. GitHub에서 PR 생성 (base: main, compare: test)
3. PR 제목: "[TECH-042] 등급별 게시판 목록 조회 API"
4. PR 설명 작성:
   - 주요 변경사항
   - Test 서버 테스트 결과
   - 특이사항
5. PM(윤종호)에게 리뷰 요청
6. 리뷰 승인 후 "Squash and merge"
7. Railway Production 자동 배포 확인
8. Production 서버 동작 확인
```

---

## 7. 커밋 컨벤션

### 7.1 커밋 메시지 형식

```bash
<타입>: <작업내용>, <Linear ID>
```

#### 예시
```bash
git commit -m "feature: 회원가입 API 개발, TECH-012"
git commit -m "fix: 로그인 버그 수정, TECH-034"
git commit -m "docs: API 명세서 업데이트, TECH-050"
git commit -m "style: Prettier 적용, TECH-051"
```

### 7.2 타입 종류

| 타입 | 설명 | 예시 |
|------|------|------|
| `feature` | 새로운 기능 추가 | `feature: 등급별 게시판 API, TECH-042` |
| `fix` | 버그 수정 | `fix: 로그인 에러 처리, TECH-056` |
| `docs` | 문서 수정 | `docs: README 업데이트, TECH-060` |
| `style` | 코드 포맷팅, 리팩토링 | `style: ESLint 적용, TECH-061` |
| `refactor` | 코드 리팩토링 (기능 변경 없음) | `refactor: API 응답 구조 개선, TECH-070` |
| `test` | 테스트 코드 추가/수정 | `test: 게시판 API 유닛 테스트, TECH-080` |
| `chore` | 빌드, 설정 등 기타 작업 | `chore: 의존성 업데이트, TECH-090` |

### 7.3 커밋 메시지 작성 가이드

#### ✅ 좋은 예시
```bash
feature: 등급별 게시판 목록 조회 API 구현, TECH-042
fix: Supabase 연결 에러 처리, TECH-056
docs: 커뮤니티 API 명세서 작성, TECH-060
```

#### ❌ 나쁜 예시
```bash
update  # 타입 없음, Linear ID 없음
수정    # 영어 사용 권장
WIP     # 구체적이지 않음
```

#### 📝 작성 원칙
* **한글 또는 영어** 사용 (팀 내 일관성 유지)
* **현재형 동사** 사용 ("추가함" ❌, "추가" ✅)
* **구체적으로** 작성 ("수정" ❌, "로그인 버그 수정" ✅)
* **Linear ID 필수** 포함

---

## 8. 코드 리뷰 가이드

### 8.1 리뷰어 (PM) 체크리스트

#### 기능 동작
- [ ] 요구사항대로 동작하는가?
- [ ] 예외 처리가 잘 되어 있는가?
- [ ] 에러 메시지가 명확한가?

#### 코드 품질
- [ ] 코드가 읽기 쉬운가?
- [ ] 변수/함수명이 의미 있는가?
- [ ] 중복 코드가 없는가?
- [ ] 주석이 필요한 곳에 있는가?

#### 성능
- [ ] 불필요한 API 호출이 없는가?
- [ ] N+1 쿼리 문제가 없는가?
- [ ] 메모리 누수 가능성이 없는가?

#### 보안
- [ ] 인증/인가가 적절한가?
- [ ] SQL Injection 방지가 되어 있는가?
- [ ] 민감 정보가 노출되지 않는가?

### 8.2 PR 작성자 체크리스트

PR 생성 전 확인:
- [ ] 로컬에서 테스트 완료
- [ ] Lint/Prettier 적용
- [ ] 불필요한 console.log 제거
- [ ] TODO 주석 정리
- [ ] Linear 이슈와 연결

### 8.3 리뷰 코멘트 작성 가이드

#### ✅ 좋은 코멘트 예시
```
✨ 제안: 이 부분은 util 함수로 분리하면 재사용성이 좋을 것 같습니다.

❓ 질문: 왜 Promise.all 대신 for loop을 사용하셨나요?

⚠️ 버그: 이 조건에서 null 체크가 필요할 것 같습니다.

👍 칭찬: 에러 처리가 꼼꼼하네요!
```

#### ❌ 나쁜 코멘트 예시
```
이거 왜 이렇게 했어요?  # 공격적
틀렸습니다.            # 구체적이지 않음
```

---

## 9. 향후 계획

### Phase 1 (현재 - MVP 단계)
```yaml
기간: 2025년 11월 ~ 2026년 1월 (2개월)
팀 규모: 5명
전략: 3 브랜치 전략 (dev → test → main)
특징:
  - dev 브랜치에서 공동 협업
  - Feature 브랜치 없음
  - 빠른 개발 속도 우선
  - Squash and Merge 사용
목표:
  - MVP 완성 및 스마트인재개발원 데모
```

### Phase 2 (MVP 완료 후)
```yaml
조건:
  - 협업 인원 10명 이상
  - 충돌 빈도 일 2-3회 이상
  - 4명 이상이 같은 파일 수정
  - PR당 코드 리뷰 300줄 이상

변경사항:
  - Feature Branch 전략 도입
  - feature/TECH-XXX-기능명 브랜치 생성
  - dev 브랜치에서 통합

브랜치 구조:
  feature/* → dev → test → main
  bugfix/* → dev → test → main
  hotfix/* → main (긴급)
```

### Phase 3 (대규모 확장)
```yaml
조건:
  - 협업 인원 20명 이상
  - PR당 코드 리뷰 500줄 이상

변경사항:
  - Git Flow 전략
  - Release 브랜치 도입
  - 버전 관리 (v1.0.0)

브랜치 구조:
  feature/* → dev → release/* → main
                  ↓
              hotfix/* → main
```

---

## 참고 자료

### 유용한 Git 명령어

```bash
# 브랜치 확인
git branch -a

# 최신 상태로 업데이트
git fetch origin
git pull origin dev

# 실수로 push한 경우 되돌리기 (로컬만)
git reset --soft HEAD~1

# 특정 커밋으로 되돌리기
git revert <commit-hash>

# 브랜치 삭제
git branch -d feature/old-branch
```

### VS Code 추천 확장
* GitLens - Git 히스토리 시각화
* Prettier - 코드 포맷팅
* ESLint - 코드 품질 검사
* GitHub Pull Requests - PR 관리

### 추가 문서
* [TechBuddy 기획서](./TechBuddy_기획서_v1_3.md)
* [커뮤니티 API 명세서](./커뮤니티_API명세서_v1_0.md) (작성 예정)
* [프로젝트 관리 API 명세서](./프로젝트관리_API명세서_v1_0.md)
* [데이터베이스 스키마](./데이터베이스_스키마_v1_0.md) (작성 예정)

---

## 작성 완료

**문서 버전**: v1.1
**최종 수정일**: 2025-11-18
**작성자**: 윤종호

---

## 변경 이력
- 2025-11-18: v1.1 모노레포 구조 및 초기 셋업 가이드 추가
- 2025-11-17: v1.0 초안 작성 (Linear 'Developer-work-flow' 기반)
